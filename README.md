# QuadCrypt
> [!CAUTION]
> **Этот алгоритм шифрования не подходит для использования в реальных проектах для защиты важной информации! Этот алгоритм представляет собой простую схему шифрования, основанную на "квадратичной функции", изучаемой в 9 классе (в предметах математики, алгебры или геометрии). Он крайне неэффективен для применения в реальных проектах.**

Данный алгоритм шифрования является простой схемой, основанной на "квадратичной функции", изучаемой в 9 классе (в предметах математики, алгебры или геометрии). Этот проект был выполнен за очень короткий период времени, соединяя два предмета: "математика" и "информатика" (или "информационные технологии"). Метод, использованный в этом алгоритме, весьма прост. С помощью произвольного значения $y$ происходит преобразование и шифрование $a$, $b$, и $c$. Значение $Y_0$ шифруется через формулу $Y_0 = a(X_0+b)^2 + c$, а значения от $Y_1$ и далее (то есть $Y_n$) вычисляются по формуле $Y_n = a(X_n + b)^2 + c$ (на самом деле формулы для $Y_0$ и $Y_n$ идентичны, однако формулы для вычисления $a$, $b$, $c$ для $Y_0$ и $Y_n$ различаются).

## Что такое квадратичная функция?
Для учеников младших классов, давайте кратко объясним, что такое **квадратичная функция**. Это математическое выражение, которое выглядит так:
```math
y = ax^2 + bx + c
```
где $a$, $b$, $c$ — это **константы**, то есть числа.

## Пример задачи
Приведём простой пример: $y = x^2 + 2x + 1$. Из этого уравнения видно, что **квадратичная функция — это функция, которая определяет значение $y$ в зависимости от введённого значения $x$**.

### Задача 1: Чему равно $y$, если $x = 1$?
Так как у нас есть уравнение $y = x^2 + 2x + 1$, подставим $x = 1$.
```math
y = (1)^2 + 2(1) + 1 = 1 + 2 + 1 = 4
```
Таким образом, при $x = 1$, $y = 4$.

### Задача 2: Чему равно $y$, если $x = 2$?
Теперь подставим $x = 2$.
```math
y = (2)^2 + 2(2) + 1 = 4 + 4 + 1 = 9
```
Следовательно, при $x = 2$, $y = 9$. Таким образом, мы кратко рассмотрели квадратичную функцию. Подставив значение для $x$, вы можете легко найти соответствующее значение $y$.

## Процесс работы  
### Процесс шифрования  
1. QuadCrypt принимает квадратичную функцию в виде $Y = a(X + b)^2 + c$ в качестве основной модели шифрования. Здесь $a$, $b$, $c$ — параметры, используемые в качестве ключа шифрования.  
2. Начальные значения $a_0$, $b_0$, $c_0$ вводятся произвольно.  
3. На основе этих значений создаются $a$, $b$, $c$ по следующей формуле, чтобы усложнить процесс:  
   $a = a_0 + b_0$  
   $b = b_0 + c_0$  
   $c = c_0 + a_0$  
4. Вводится открытый текст $X_0$. Обычно предполагается, что это ASCII-значение.  
5. Генерируется $fy$: $\left( a \cdot b \cdot c \right)^2$  
6. Первоначальное значение $Y$, т.е. $Y_0$, генерируется с использованием другой алгоритмической процедуры для обеспечения безопасности по сравнению с $Y_2$, $Y_3$, ..., $Y_n$.  
7. Для генерации $Y_0$ используется формула $\left( a \cdot b \cdot c \right)^2$, чтобы создать произвольное значение $fy$.  
8. Создаются $a$, $b$, $c$, которые будут использованы для генерации $Y_0$:  
   $a = \left( \left( fy \mod (a + b) \right) + a \right) \mod (b + c) + 1$  
   $b = \left( \left( b \mod (b + c + a) \right) + b \right) \mod (c + a) + 1$  
   $c = \left( \left( fy \mod (c + a) \right) + c \right) \mod (a + b) + \left( a \cdot b \cdot c \right) \mod 3$  
9. Первый шифротекст $Y_0$ вычисляется по формуле $Y_0 = a(X_0 + b)^2 + c$.  
10. Сразу после вычисления $Y_0$ происходит обновление параметров:  
    $a$ обновляется по формуле $a = \left( (Y_0 \mod X_0) \mod 11 \right) + 1$;  
    $b$ обновляется по формуле $b = \left( (Y_0 \mod b) \mod 11 \right) + 1$;  
    $c$ обновляется по формуле $c = \left( (X_0 \mod c) \mod 11 \right) + 1$.  
11. С обновленными значениями $a$, $b$, $c$ вычисляется $Y_1 = a(X_1 + b)^2 + c$, где $X_1$ — второй символ или значение открытого текста.  
12. Шаги 10 и 11 повторяются для вычисления $Y_2$, $Y_3$, ..., $Y_n$.  
13. На каждом этапе значения $a$, $b$, $c$ обновляются на основе результатов предыдущего шага, что позволяет применять разные ключи шифрования для каждого символа.  
14. По завершении всех вышеуказанных этапов создается финальный зашифрованный массив в форме $[Y_0, Y_1, ..., Y_n]$.
